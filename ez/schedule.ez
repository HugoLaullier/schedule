/*-----------------------------------------------------------------------------
BALZANO Antoine
LAULLIER Hugo
-----------------------------------------------------------------------------*/

\User declarations :
#include "../include/rapidjson/document.h"
#include "../include/rapidjson/istreamwrapper.h"
#include "../include/rapidjson/writer.h"
#include "../include/rapidjson/stringbuffer.h"
#include <fstream>
#include <iostream>
#include <vector>
#define NB_SCHEDULES 4
#define NB_COURSES 10

enum subject_t {
    MATHEMATICS, 
    PHYSICS, 
    COMPUTER_SCIENCE,
    ENGLISH
};

enum room_type_t {
    TP,
    TD,
    LABO
};

enum formation_name_t {MI, PI};

Teacher* teachers;
Room* rooms;
Promotion* promotions;
Training* trainings;

\end

\User functions:
int getData()
{
  ifstream ifs("../json/in/data.json");
  if (!ifs.is_open())
  {
      std::cerr << "Could not open file for reading!\n";
      return EXIT_FAILURE;
  }

  rapidjson::IStreamWrapper isw(ifs);

  rapidjson::Document doc{};
  doc.ParseStream(isw);

  teachers = (Teacher *) malloc(doc["teachers"].Size()*sizeof(Teacher));

  for (rapidjson::SizeType i = 0; i < doc["teachers"].Size(); i++)
  {
      Teacher teacher;
      teacher.id = i;
      if(doc["teachers"][i]["subject"] == "Mathematics")
        teacher.subject = MATHEMATICS;
        else if(doc["teachers"][i]["subject"] == "Physics")
        teacher.subject = PHYSICS;
        else if(doc["teachers"][i]["subject"] == "Computer Science")
        teacher.subject = COMPUTER_SCIENCE;
        else if(doc["teachers"][i]["subject"] == "English")
        teacher.subject = ENGLISH;
        else
            std::cerr << doc["teachers"][i]["subject"].GetString() << " is not a subject" << std::endl;
      teacher.hours_per_week = doc["teachers"][i]["hours_per_week"].GetInt();

      teachers[i] = teacher;      
  }

  rooms = (Room *) malloc(doc["rooms"].Size()*sizeof(Teacher));
  for (rapidjson::SizeType i = 0; i < doc["rooms"].Size(); i++)
  {
      Room room;
      room.id = i;
      if(doc["rooms"][i]["type"] == "TP")
        room.type = TP;
        else if(doc["rooms"][i]["type"] == "TD")
        room.type = TD;
        else if(doc["rooms"][i]["type"] == "labo")
        room.type = LABO;
        else
            std::cerr << doc["rooms"][i]["type"].GetString() << " is not a type of room" << std::endl;
      room.places = doc["rooms"][i]["places"].GetInt();

      rooms[i] = room;      
  }

  promotions = (Promotion *) malloc(doc["promotions"].Size()*sizeof(Promotion));
  for (rapidjson::SizeType i = 0; i < doc["promotions"].Size(); i++)
  {
      Promotion promotion;
      promotion.id = i;
      if(doc["promotions"][i]["training"] == "MI")
        promotion.type = MI;
        else if(doc["promotions"][i]["training"] == "PI")
        promotion.type = PI;
        else
            std::cerr << doc["promotions"][i]["training"].GetString() << " is not a training" << std::endl;
      promotion.places = doc["promotions"][i]["nb_of_students"].GetInt();

      promotions[i] = promotion;      
  }

  trainings = (Training *) malloc(doc["trainings"].Size()*sizeof(Training));
  for (rapidjson::SizeType i = 0; i < doc["trainings"].Size(); i++)
  {
      Promotion promotion;
      if(doc["trainings"][i]["name"] == "MI")
        promotion.type = MI;
        else if(doc["trainings"][i]["name"] == "PI")
        promotion.type = PI;
        else
            std::cerr << doc["trainings"][i]["name"].GetString() << " is not a training" << std::endl;
      Subject* subjects = (Subject *) malloc(doc["trainings"][i]["subjects"].Size()*sizeof(Subject));
      for (rapidjson::SizeType j = 0; j < doc["trainings"][i]["subjects"].Size(); j++)
      {
          Subject subject;
          if(doc["trainings"][i]["subjects"][j]["name"] == "Mathematics")
        subject.name = MATHEMATICS;
        else if(doc["trainings"][i]["subjects"][j]["name"] == "Physics")
        subject.name = PHYSICS;
        else if(doc["trainings"][i]["subjects"][j]["name"] == "Computer Science")
        subject.name = COMPUTER_SCIENCE;
        else if(doc["trainings"][i]["subjects"][j]["name"] == "English")
        subject.name = ENGLISH;
        else
            std::cerr << doc["trainings"][i]["subjects"][j]["name"].GetString() << " is not a subject" << std::endl;
        subjects[i]=subject
      }

      promotion[i].subjects = subjects;

      promotions[i] = promotion;      
  }



}
\end

\User CUDA:
\end

\Before everything else function:
getData();
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
Promotion {
    int id;
    int training;
    int nb_of_students;
}

Subject {
    int name;
    int hours_per_week;
    int room;
}

Training {
    int name;
    Subject * subjects;
}

Room {
    int id;
    int type;
    int places;
}

Teacher {
    int id;   // teacher id
    // add specific constraint for a teacher here (vector of constraints)
    // maybe add a struct/Class for constraints
    int subject;
    int hours_per_week;
}

Course {
    int subject;
    int teacher_id;
    int room_id;     
}

Schedule {
    Course courses[NB_COURSES]; 
}


GenomeClass {
    Schedule *schedules;
}
\end

\GenomeClass::display:
\end

\GenomeClass::initializer : 
\end

\GenomeClass::crossover :
// create child (initialized to parent1) out of parent1 and parent2 
\end

\GenomeClass::mutator: // all the values in here are found by trial and error
\end

\GenomeClass::evaluator: // Returns the score
\end

\User Makefile options:
\end

\Default run parameters :
    Number of generations : 100    // NB_GEN
    Time limit: 0                  // In seconds, 0 to deactivate
    Population size : 4096 
    Offspring size : 100% 
    Mutation probability : 1       // MUT_PROB
    Crossover probability : 1      // XOVER_PROB
    Evaluator goal : minimise      // Maximise
    Selection operator: Tournament 10
    Surviving parents: 100%        // percentage or absolute  
    Surviving offspring: 100%
    Reduce parents operator: Tournament 2
    Reduce offspring operator: Tournament 2
    Final reduce operator: Tournament 7
    Elitism: weak   // Weak (best of parents+offspring) or 
                    //Strong (best of parents)
    Elite: 1
    Print stats: true
    Generate csv stats file:false
    Generate gnuplot script:false
    Generate R script:false
    Plot stats:true

    Remote island model: true      // run ./schedule --serverPort 2930
    IP file: ip.txt                // File containing all the remote island's IP
    Server port : 2929             // why not
    Migration probability: 0.333 

    Save population: false
    Start from file:false
\end
