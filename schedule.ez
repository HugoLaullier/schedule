/*-----------------------------------------------------------------------------
BALZANO Antoine
LAULLIER Hugo
-----------------------------------------------------------------------------*/

\User declarations :
#include "include/rapidjson/document.h"
#include "include/rapidjson/istreamwrapper.h"
#include "include/rapidjson/writer.h"
#include "include/rapidjson/stringbuffer.h"
#include <fstream>
#include <iostream>
#include <vector>
#define NB_SCHEDULES 4*5*36 // verif nb of weeks.
#define NB_COURSES 10 // 10 courses per schedule at maximum

#define NB_SUBJECTS 4
enum subject_t {
    MATHEMATICS, 
    PHYSICS, 
    COMPUTER_SCIENCE,
    ENGLISH
};

#define NB_ROOM_TYPES 3
enum room_type_t {
    TP,
    TD,
    LABO
};

enum formation_name_t {MI, PI};

struct Promotion {
    int id;
    int training;
    int nb_of_students;
};

struct Subject {
    int name;
    int hours_per_week;
    int room;
};

struct Training {
    int name;
    Subject * subjects;
};

struct Room {
    int id;
    int type;
    int places;
};

struct Teacher {
    int id; // teacher id
    // add specific constraint for a teacher here (vector of constraints)
    // maybe add a struct/Class for constraints
    int subject;
    int hours_per_week;
};

size_t nb_teachers;
size_t nb_rooms;
size_t nb_promotions;
size_t nb_trainings;
struct Teacher* teachers;
struct Room* rooms;
struct Promotion* promotions;
struct Training* trainings;

\end

\User functions:
int getData() {
    ifstream ifs("json/in/data.json");
    if (!ifs.is_open()) {
        std::cerr << "Could not open file for reading!\n";
        return EXIT_FAILURE;
    }

    rapidjson::IStreamWrapper isw(ifs);

    rapidjson::Document doc{};
    doc.ParseStream(isw);
    nb_teachers = doc["teachers"].Size();
    teachers = (Teacher *) malloc(nb_teachers*sizeof(Teacher));

    for (rapidjson::SizeType i = 0; i < nb_teachers; i++) {
        Teacher teacher;
        teacher.id = i;
        if(doc["teachers"][i]["subject"] == "Mathematics")
        teacher.subject = MATHEMATICS;
        else if(doc["teachers"][i]["subject"] == "Physics")
        teacher.subject = PHYSICS;
        else if(doc["teachers"][i]["subject"] == "Computer Science")
        teacher.subject = COMPUTER_SCIENCE;
        else if(doc["teachers"][i]["subject"] == "English")
        teacher.subject = ENGLISH;
        else
            std::cerr << doc["teachers"][i]["subject"].GetString() << " is not"
            " a subject" << std::endl;
        teacher.hours_per_week = doc["teachers"][i]["hours_per_week"].GetInt();

        teachers[i] = teacher;
    }

    nb_rooms = doc["rooms"].Size();
    rooms = (Room *) malloc(nb_rooms*sizeof(Room));
    for (rapidjson::SizeType i = 0; i < nb_rooms; i++) {
        Room room;
        room.id = i;
        if(doc["rooms"][i]["type"] == "TP")
        room.type = TP;
        else if(doc["rooms"][i]["type"] == "TD")
        room.type = TD;
        else if(doc["rooms"][i]["type"] == "labo")
        room.type = LABO;
        else
            std::cerr << doc["rooms"][i]["type"].GetString() << " is not a type"
            " of room" << std::endl;
        room.places = doc["rooms"][i]["places"].GetInt();
        rooms[i] = room;
    }

    nb_promotions = doc["promotions"].Size();
    promotions = (Promotion *) malloc(nb_promotions*sizeof(Promotion));
    for (rapidjson::SizeType i = 0; i < nb_promotions; i++) {
        Promotion promotion;
        promotion.id = i;
        if(doc["promotions"][i]["training"] == "MI")
        promotion.training = MI;
        else if(doc["promotions"][i]["training"] == "PI")
        promotion.training = PI;
        else
            std::cerr << doc["promotions"][i]["training"].GetString() << " is"
            " not a training" << std::endl;
        promotion.nb_of_students = 
            doc["promotions"][i]["nb_of_students"].GetInt();
        promotions[i] = promotion;
    }

    nb_trainings = doc["trainings"].Size();
    trainings = (Training *) malloc(nb_trainings*sizeof(Training));
    for (rapidjson::SizeType i = 0; i < nb_trainings; i++) {
        Training training;
        if(doc["trainings"][i]["name"] == "MI")
        training.name = MI;
        else if(doc["trainings"][i]["name"] == "PI")
        training.name = PI;
        else
            std::cerr << doc["trainings"][i]["name"].GetString() << " is not a"
            " training" << std::endl;
        Subject* subjects = (Subject *) malloc(
            doc["trainings"][i]["subjects"].Size()*sizeof(Subject));
        for (rapidjson::SizeType j = 0; 
             j < doc["trainings"][i]["subjects"].Size(); 
             j++) {
            Subject subject;
            if(doc["trainings"][i]["subjects"][j]["name"] == "Mathematics")
            subject.name = MATHEMATICS;
            else if(doc["trainings"][i]["subjects"][j]["name"] == "Physics")
            subject.name = PHYSICS;
            else if(doc["trainings"][i]["subjects"][j]["name"] == 
                "Computer Science")
            subject.name = COMPUTER_SCIENCE;
            else if(doc["trainings"][i]["subjects"][j]["name"] == "English")
            subject.name = ENGLISH;
            else
                std::cerr << 
                doc["trainings"][i]["subjects"][j]["name"].GetString() << 
                " is not a subject" << std::endl;
            subject.hours_per_week = 
                doc["trainings"][i]["subjects"][j]["hours_per_week"].GetInt();
                if(doc["trainings"][i]["subjects"][j]["room"] == "TP")
            subject.room = TP;
            else if(doc["trainings"][i]["subjects"][j]["room"] == "TD")
            subject.room = TD;
            else if(doc["trainings"][i]["subjects"][j]["room"] == "labo")
            subject.room = LABO;
            else
                std::cerr << 
                doc["trainings"][i]["subjects"][j]["room"].GetString() << 
                " is not a type of room" << std::endl;
            subjects[i]=subject;
        }

        training.subjects = subjects;
        trainings[i] = training;
    }

  return 0;
}

void showData() {
    std::cout << "DEBUG : " << trainings[0].subjects[0].hours_per_week << 
    std::endl; 
}
\end

\User CUDA:
\end

\Before everything else function:
getData(); // To store data from json in arrays
// TODO do the same for constraints
showData(); // To debug
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass {

    //int rooms     [NB_SCHEDULES*NB_COURSES];
    //int teachers  [NB_SCHEDULES*NB_COURSES];
    //int promotions[NB_SCHEDULES*NB_COURSES];
    // indicate how many courses there are for each schedule at the same time
    //j from 0 to NB_COURSES and i from 0 to NB_SCHEDULES

    // element i*(1+NB_COURSES*3)+0 -> 
    //     number of courses per schedule (from 0 to NB_COURSES)
    //element i*(1+NB_COURSES*3)+1+j*1 -> rooms
    //element i*(1+NB_COURSES*3)+1+NB_COURSES+j -> rooms
    //element i*(1+NB_COURSES*3)+1+2*NB_COURSES+j -> rooms

    int courses[NB_SCHEDULES*(1+NB_COURSES*3)];
}
\end

\GenomeClass::display:
\end

\GenomeClass::initializer :
printf("hello1\n");
static int test  =0;
test++;
printf("hello\n");
for (int i = 0; i < NB_SCHEDULES; i++) {
    Genome.courses[i*(1+NB_COURSES*3)] = (int)random(0,NB_COURSES);
    for (int j = 0; j < NB_COURSES; j++) {
        //Genome.rooms     [i*NB_COURSES+j] = 0; //random(0,nb_rooms);
        //Genome.teachers  [i*NB_COURSES+j] = 0; //random(0,nb_teachers);
        //Genome.promotions[i*NB_COURSES+j] = 0; //random(0,nb_promotions);
        //printf("%i,%i\n",i*NB_COURSES+j, NB_SCHEDULES*NB_COURSES);
        Genome.courses[i*(1+NB_COURSES*3)+1+j]   = 0;
        Genome.courses[i*(1+NB_COURSES*3)+1+NB_COURSES+j] = 0;
        Genome.courses[i*(1+NB_COURSES*3)+1+2*NB_COURSES+j] = 0;
        printf("--- %i;;%i\n", i*(1+NB_COURSES*3)+1+2*NB_COURSES+j, NB_SCHEDULES*(1+NB_COURSES*3));
        //printf("-%i\n", (int)random(0,(int)nb_rooms));
    }
    printf("%i,%i\n",i, test);
}
printf("end\n");
\end

\GenomeClass::crossover :
// create child (initialized to parent1) out of parent1 and parent2 
\end

\GenomeClass::mutator: // all the values in here are found by trial and error
\end

\GenomeClass::evaluator: // Returns the score
return 1;
\end

\User Makefile options:
\end

\Default run parameters :
    Number of generations : 100    // NB_GEN
    Time limit: 0                  // In seconds, 0 to deactivate
    Population size : 4096 
    Offspring size : 100% 
    Mutation probability : 1       // MUT_PROB
    Crossover probability : 1      // XOVER_PROB
    Evaluator goal : minimise      // Maximise
    Selection operator: Tournament 10
    Surviving parents: 100%        // percentage or absolute  
    Surviving offspring: 100%
    Reduce parents operator: Tournament 2
    Reduce offspring operator: Tournament 2
    Final reduce operator: Tournament 7
    Elitism: weak   // Weak (best of parents+offspring) or 
                    //Strong (best of parents)
    Elite: 1
    Print stats: true
    Generate csv stats file:false
    Generate gnuplot script:false
    Generate R script:false
    Plot stats:true

    Remote island model: false      // run ./schedule --serverPort 2930
    IP file: ip.txt                // File containing all the remote island's IP
    Server port : 2929             // why not
    Migration probability: 0.333 

    Save population: false
    Start from file:false
\end