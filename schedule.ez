/*-----------------------------------------------------------------------------
BALZANO Antoine
LAULLIER Hugo
-----------------------------------------------------------------------------*/

\User declarations :
#include "include/rapidjson/document.h"
#include "include/rapidjson/istreamwrapper.h"
#include "include/rapidjson/writer.h"
#include "include/rapidjson/stringbuffer.h"
#include <fstream>
#include <iostream>
#include <vector>

#define DEBUG false

#define NB_SLOTS 20 // verif nb of weeks. (20 = 4*5)
#define NB_PROMOTIONS 4
#define EMPTY -1
#define PENALITY_VERY_HIGH 1000000
#define PENALITY_HIGH_TEACHER 50
#define PENALITY_MEDIUM_TEACHER 10
#define PENALITY_LOW_TEACHER 3
#define PENALITY_MEDIUM_STUDENT 3
#define PENALITY_LOW_STUDENT 1

#define NB_SUBJECTS 4
enum subject_t {
    MATHEMATICS, 
    PHYSICS, 
    COMPUTER_SCIENCE,
    ENGLISH
};

#define NB_ROOM_TYPES 3
enum room_type_t {
    TP,
    TD
};

enum formation_name_t {MI, PI};

struct Promotion {
    int id;
    int training;
    int nb_of_students;
};

struct Subject {
    int name;
    int hours_per_week;
    int room;
};

struct Training {
    int name;
    Subject subjects[NB_SUBJECTS];
};

struct Room {
    int id;
    room_type_t type;
    int nb_places;
    subject_t subject;
};

struct Teacher {
    int id; // teacher id
    // add specific constraint for a teacher here (vector of constraints)
    // maybe add a struct/Class for constraints
    int subject;
    int hours_per_week;
};

size_t nb_teachers;
size_t nb_rooms;
size_t nb_promotions;
size_t nb_trainings;
struct Teacher* teachers;
struct Room* rooms;
struct Promotion* promotions;
struct Training* trainings;

\end

\User functions:
int getData() {
    ifstream ifs("json/in/data.json");
    if (!ifs.is_open()) {
        std::cerr << "Could not open file for reading!\n";
        return EXIT_FAILURE;
    }

    rapidjson::IStreamWrapper isw(ifs);

    rapidjson::Document doc{};
    doc.ParseStream(isw);
    nb_teachers = doc["teachers"].Size();
    teachers = (Teacher *) malloc(nb_teachers*sizeof(Teacher));

    for (rapidjson::SizeType i = 0; i < nb_teachers; i++) {
        Teacher teacher;
        teacher.id = i;
        if(doc["teachers"][i]["subject"] == "Mathematics")
            teacher.subject = MATHEMATICS;
        else if(doc["teachers"][i]["subject"] == "Physics")
            teacher.subject = PHYSICS;
        else if(doc["teachers"][i]["subject"] == "Computer Science")
            teacher.subject = COMPUTER_SCIENCE;
        else if(doc["teachers"][i]["subject"] == "English")
            teacher.subject = ENGLISH;
        else
            std::cerr << doc["teachers"][i]["subject"].GetString() << " is not"
            " a subject" << std::endl;
        teacher.hours_per_week = doc["teachers"][i]["hours_per_week"].GetInt();

        teachers[i] = teacher;
    }

    nb_rooms = doc["rooms"].Size();
    rooms = (Room *) malloc(nb_rooms*sizeof(Room));
    for (rapidjson::SizeType i = 0; i < nb_rooms; i++) {
        Room room;
        room.id = i;
        if(doc["rooms"][i]["type"] == "TP") {
            room.type = TP;
            if (doc["rooms"][i]["subject"] == "Computer Science") {
                room.subject = COMPUTER_SCIENCE;
            }
            else if (doc["rooms"][i]["subject"] == "Mathematics") {
                room.subject = MATHEMATICS;
            }
            else if (doc["rooms"][i]["subject"] == "English") {
                room.subject = ENGLISH;
            }
            else if (doc["rooms"][i]["subject"] == "Physics") {
                room.subject = PHYSICS;
            }
            else {
                std::cerr << doc["rooms"][i]["subject"].GetString() << 
                " is not a subject of room" << std::endl;
            }
        }
        else if(doc["rooms"][i]["type"] == "TD") {
            room.type = TD;
        }
        else {
            std::cerr << doc["rooms"][i]["type"].GetString() << " is not a type"
            " of room" << std::endl;
        }
        room.nb_places = doc["rooms"][i]["places"].GetInt();
        rooms[i] = room;
    }

    nb_promotions = doc["promotions"].Size();
    promotions = (Promotion *) malloc(nb_promotions*sizeof(Promotion));
    for (rapidjson::SizeType i = 0; i < nb_promotions; i++) {
        Promotion promotion;
        promotion.id = i;
        if(doc["promotions"][i]["training"] == "MI")
            promotion.training = MI;
        else if(doc["promotions"][i]["training"] == "PI")
            promotion.training = PI;
        else
            std::cerr << doc["promotions"][i]["training"].GetString() << " is"
            " not a training" << std::endl;
        promotion.nb_of_students = 
            doc["promotions"][i]["nb_of_students"].GetInt();
        promotions[i] = promotion;
    }

    nb_trainings = doc["trainings"].Size();
    trainings = (Training *) malloc(nb_trainings*sizeof(Training));
    for (rapidjson::SizeType i = 0; i < nb_trainings; i++) {
        Training training;
        if(doc["trainings"][i]["name"] == "MI")
            training.name = MI;
        else if(doc["trainings"][i]["name"] == "PI")
            training.name = PI;
        else
            std::cerr << doc["trainings"][i]["name"].GetString() << " is not a"
            " training" << std::endl;
        
        for (rapidjson::SizeType j = 0; 
             j < doc["trainings"][i]["subjects"].Size(); 
             j++) {
            Subject subject;
            if(doc["trainings"][i]["subjects"][j]["name"] == "Mathematics") {
                subject.name = MATHEMATICS;
            }
            else if(doc["trainings"][i]["subjects"][j]["name"] == "Physics") {
                subject.name = PHYSICS;
            }
            else if(doc["trainings"][i]["subjects"][j]["name"] == 
                "Computer Science") {
                subject.name = COMPUTER_SCIENCE;
                }
            else if(doc["trainings"][i]["subjects"][j]["name"] == "English") {
                subject.name = ENGLISH;
            }
            else {
                std::cerr << 
                doc["trainings"][i]["subjects"][j]["name"].GetString() << 
                " is not a subject" << std::endl;
            }
            subject.hours_per_week = 
                doc["trainings"][i]["subjects"][j]["hours_per_week"].GetInt();
            if(doc["trainings"][i]["subjects"][j]["room"] == "TP") {
                subject.room = TP;
            }
            else if(doc["trainings"][i]["subjects"][j]["room"] == "TD") {
                subject.room = TD;
            }
            else {
                std::cerr << 
                doc["trainings"][i]["subjects"][j]["room"].GetString() << 
                " is not a type of room" << std::endl;
            }
            training.subjects[subject.name] = subject;
        }
        trainings[i] = training;
    }

  return 0;
}

\end

\User CUDA:
\end

\Before everything else function:
getData(); // To store data from json in arrays
// TODO do the same for constraints
\end

\After everything else function:
\end

\At the beginning of each generation function:
\end

\At the end of each generation function:
\end

\At each generation before reduce function:
\end

\User classes :
GenomeClass {
    // 1st element : room id
    // 2nd element : teacher id
    int courses [NB_SLOTS*NB_PROMOTIONS*2];
}
\end

\GenomeClass::display:
\end

\GenomeClass::initializer :
for (size_t i = 0; i < nb_promotions; i++) {
    for (size_t j = 0; j < NB_SLOTS; j++) {
        Genome.courses[2*NB_SLOTS*i+2*j]   = (int)random(-1,nb_rooms-1);
        Genome.courses[2*NB_SLOTS*i+2*j+1] = (int)random(-1,nb_teachers-1);
    }
}
if(DEBUG) {
    for (size_t i = 0; i < nb_promotions*NB_SLOTS*2; i++)
        printf("%d,", Genome.courses[i]);
    printf("end\n");
}
\end

\GenomeClass::crossover :
for (size_t i = 0; i < nb_promotions; i++) {
    size_t nLocus = (int)random(0, NB_SLOTS);
    for (size_t j = nLocus; j < NB_SLOTS; j++) {
        child.courses[2*NB_SLOTS*i+2*j]   = parent2.courses[2*NB_SLOTS*i+2*j];
        child.courses[2*NB_SLOTS*i+2*j+1] = parent2.courses[2*NB_SLOTS*i+2*j+1];
    }
}
\end

\GenomeClass::mutator:
for (size_t i = 0; i < nb_promotions; i++) {
    float pMutPerGene = 1.0/(2*NB_SLOTS);
    if(tossCoin(pMutPerGene)) {
        for (size_t j = 0; j < NB_SLOTS; j++) {
            Genome.courses[2*NB_SLOTS*i+2*j]   = (int)random(-1,nb_rooms-1); 
            Genome.courses[2*NB_SLOTS*i+2*j+1] = (int)random(-1,nb_teachers-1);
        }
    }
}
\end

\GenomeClass::evaluator: //TODO
int nScore = 0;
// TEACHER CONSTRAINTS
for (size_t k = 0; k < nb_teachers; k++) {
    int worked_schedules [20] = {0};
    int nb_courses = 0;
    for (size_t i = 0; i < nb_promotions; i++) {
        for (size_t j = 0; j < NB_SLOTS; j++) {
            if (Genome.courses[2*NB_SLOTS*i+2*j+1] == (int)k) {
                worked_schedules[j] ++;
                nb_courses += 2;
            }
        }
    }
    for (size_t i = 0; i < 5; i++) {
        int nb_courses_per_day = 0;
        for (size_t j = 0; j < 4; j++) {
            nb_courses_per_day += worked_schedules[i*4+j];
            if (worked_schedules[i*4+j] > 1) {
                // can't do 2 courses at the same time
                nScore += PENALITY_VERY_HIGH;
            }
        }
        if (nb_courses_per_day == 1 || nb_courses_per_day == 4) {
            // nearly empty day or too busy day
            nScore += PENALITY_LOW_TEACHER;
        }
        if (worked_schedules[i*4+0] && !worked_schedules[i*4+1] &&
            !worked_schedules[i*4+2] && worked_schedules[i*4+3]) {
            // large hole in a day
            nScore += PENALITY_MEDIUM_TEACHER;
        }
        if ((worked_schedules[i*4+0] && 
            !worked_schedules[i*4+1] &&
            worked_schedules[i*4+2]) ||
            (worked_schedules[i*4+1] && 
            !worked_schedules[i*4+2] &&
            worked_schedules[i*4+3])) {
            // smale hole in a day
            nScore += PENALITY_LOW_TEACHER;
        }
    }
    if (nb_courses < teachers[k].hours_per_week) {
        // under service
        nScore += PENALITY_VERY_HIGH;
    }
    if (nb_courses > teachers[k].hours_per_week) {
        // additional hour
        nScore += PENALITY_LOW_TEACHER;
    }
    // TODO add specific constraints
}
// ROOMS CONSTRAINTS

// PROMOTIONS CONSTRAINTS
for (size_t i = 0; i < nb_promotions; i++) {
    struct Training cur_training = trainings[promotions[i].training];
    int count_hours[NB_SUBJECTS] = {0};
    for (size_t j = 0; j < NB_SLOTS; j++) {
        count_hours[teachers[Genome.courses[2*NB_SLOTS*i+2*j+1]].subject] += 2;
    }
    for (int j = 0; j < NB_SUBJECTS; j++) {
        if (cur_training.subjects[j].hours_per_week != count_hours[j]) {
            // trainings / formation need to be respected
            nScore += PENALITY_VERY_HIGH;
            break;
        }
    }
}
return nScore;
\end

\User Makefile options:
\end

\Default run parameters :
    Number of generations : 100    // NB_GEN
    Time limit: 0                  // In seconds, 0 to deactivate
    Population size : 15000
    Offspring size : 10000
    Mutation probability : 1     // MUT_PROB
    Crossover probability : 1      // XOVER_PROB
    Evaluator goal : minimise      // Maximise
    Selection operator: Tournament 10
    Surviving parents: 100%        // percentage or absolute  
    Surviving offspring: 100%
    Reduce parents operator: Tournament 2
    Reduce offspring operator: Tournament 2
    Final reduce operator: Tournament 7
    Elitism: weak   // Weak (best of parents+offspring) or 
                    //Strong (best of parents)
    Elite: 1
    Print stats: true
    Generate csv stats file:false
    Generate gnuplot script:false
    Generate R script:false
    Plot stats:true

    Remote island model: false      // run ./schedule --serverPort 2930
    IP file: ip.txt                // File containing all the remote island's IP
    Server port : 2929             // why not
    Migration probability: 0.333 

    Save population: false
    Start from file:false
\end